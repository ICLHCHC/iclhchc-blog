---
sidebar_position: 2
---

# 自动生成

```mdx-code-block
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
```

Docusaurus 可以 **自动根据文件系统结构创建侧边栏**：每个文件夹创建一个侧边栏类别，每个文件创建一个文档链接。

```ts
type SidebarItemAutogenerated = {
  type: 'autogenerated';
  dirName: string; // 用于生成侧边栏切片的源文件夹（相对于 docs）
};
```

Docusaurus 可以从你的文档文件夹生成一个完整的侧边栏：

```js title="sidebars.js"
export default {
  myAutogeneratedSidebar: [
    // 高亮开始
    {
      type: 'autogenerated',
      dirName: '.', // '.' 代表当前的 docs 文件夹
    },
    // 高亮结束
  ],
};
```

一个 `autogenerated` 项目会被 Docusaurus 转换为一个 **侧边栏切片**（在 [类别简写](items.mdx#category-shorthand) 中也有讨论）：一个类型为 `doc` 或 `category` 的项目列表，因此你可以在一个侧边栏层级中从多个目录拼接 **多个 `autogenerated` 项目**，并与常规侧边栏项目交错。

<details>
<summary>一个真实的示例</summary>

考虑以下文件结构：

```bash
docs
├── api
│   ├── product1-api
│   │   └── api.md
│   └── product2-api
│       ├── basic-api.md
│       └── pro-api.md
├── intro.md
└── tutorials
    ├── advanced
    │   ├── advanced1.md
    │   ├── advanced2.md
    │   └── read-more
    │       ├── resource1.md
    │       └── resource2.md
    ├── easy
    │   ├── easy1.md
    │   └── easy2.md
    ├── tutorial-end.md
    ├── tutorial-intro.md
    └── tutorial-medium.md
```

假设每个文档的 ID 就是它的文件名。如果你定义一个自动生成的侧边栏如下：

```js title="sidebars.js"
export default {
  mySidebar: [
    'intro',
    {
      type: 'category',
      label: '教程',
      items: [
        'tutorial-intro',
        // 高亮开始
        {
          type: 'autogenerated',
          dirName: 'tutorials/easy', // 从 docs/tutorials/easy 生成侧边栏切片
        },
        // 高亮结束
        'tutorial-medium',
        // 高亮开始
        {
          type: 'autogenerated',
          dirName: 'tutorials/advanced', // 从 docs/tutorials/advanced 生成侧边栏切片
        },
        // 高亮结束
        'tutorial-end',
      ],
    },
    // 高亮开始
    {
      type: 'autogenerated',
      dirName: 'api', // 从 docs/api 生成侧边栏切片
    },
    // 高亮结束
    {
      type: 'category',
      label: '社区',
      items: ['team', 'chat'],
    },
  ],
};
```

它会解析为：

```js title="sidebars.js"
export default {
  mySidebar: [
    'intro',
    {
      type: 'category',
      label: '教程',
      items: [
        'tutorial-intro',
        // 高亮开始
        // docs/tutorials/easy 中的两个文件
        'easy1',
        'easy2',
        // 高亮结束
        'tutorial-medium',
        // 高亮开始
        // docs/tutorials/advanced 中的两个文件和一个文件夹
        'advanced1',
        'advanced2',
        {
          type: 'category',
          label: '阅读更多',
          items: ['resource1', 'resource2'],
        },
        // 高亮结束
        'tutorial-end',
      ],
    },
    // 高亮开始
    // docs/api 中的两个文件夹
    {
      type: 'category',
      label: 'product1-api',
      items: ['api'],
    },
    {
      type: 'category',
      label: 'product2-api',
      items: ['basic-api', 'pro-api'],
    },
    // 高亮结束
    {
      type: 'category',
      label: '社区',
      items: ['team', 'chat'],
    },
  ],
};
```

请注意，自动生成的源目录本身不会成为类别：只有它们包含的项目会成为类别。这就是我们所说的“侧边栏切片”。

</details>

## 类别索引约定 {#category-index-convention}

Docusaurus 可以自动将类别链接到其索引文档。

类别索引文档是遵循以下文件名约定的文档：

- 命名为 `index`（不区分大小写）：`docs/Guides/index.md`
- 命名为 `README`（不区分大小写）：`docs/Guides/README.mdx`
- 与父文件夹同名：`docs/Guides/Guides.md`

这相当于使用带有 [文档链接](items.mdx#category-doc-link) 的类别：

```js title="sidebars.js"
export default {
  docs: [
    // 高亮开始
    {
      type: 'category',
      label: 'Guides',
      link: {type: 'doc', id: 'Guides/index'},
      items: [],
    },
    // 高亮结束
  ],
};
```

:::tip

将你的介绍文档命名为 `README.md` 可以使其在使用 GitHub 界面浏览文件夹时显示，而使用 `index.md` 则使行为更符合 HTML 文件的服务方式。

:::

:::tip

如果一个文件夹只有一个索引页面，它将被转换为链接而不是类别。这对于 **资源归集** 非常有用：

```
some-doc
├── index.md
├── img1.png
└── img2.png
```

:::

<details>

<summary>自定义类别索引匹配</summary>

可以选择退出任何类别索引约定，或定义更多约定。你可以通过 [`sidebarItemsGenerator`](#customize-the-sidebar-items-generator) 回调注入自己的 `isCategoryIndex` 匹配器。例如，你还可以选择 `intro` 作为另一个可自动成为类别索引的文件名。

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        async sidebarItemsGenerator({
          ...args,
          isCategoryIndex: defaultCategoryIndexMatcher, // 默认匹配器实现，见下文
          defaultSidebarItemsGenerator,
        }) {
          return defaultSidebarItemsGenerator({
            ...args,
            // 高亮开始
            isCategoryIndex(doc) {
              return (
                // 还选择 intro.md 除了默认的那些
                doc.fileName.toLowerCase() === 'intro' ||
                defaultCategoryIndexMatcher(doc)
              );
            },
            // 高亮结束
          });
        },
      },
    ],
  ],
};
```

或者选择不使用任何类别索引约定。

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        async sidebarItemsGenerator({
          ...args,
          isCategoryIndex: defaultCategoryIndexMatcher, // 默认匹配器实现，见下文
          defaultSidebarItemsGenerator,
        }) {
          return defaultSidebarItemsGenerator({
            ...args,
            // 高亮开始
            isCategoryIndex() {
              // 没有文档会被自动选为类别索引
              return false;
            },
            // 高亮结束
          });
        },
      },
    ],
  ],
};
```

`isCategoryIndex` 匹配器将提供三个字段：

- `fileName`：文件名，不带扩展名，保留大小写
- `directories`：目录名列表 _从最低级到最高级_，相对于文档根目录
- `extension`：文件扩展名，带有前导点。

例如，对于位于 `guides/sidebar/autogenerated.md` 的文档文件，匹配器接收的属性为：

```js
const props = {
  fileName: 'autogenerated',
  directories: ['sidebar', 'guides'],
  extension: '.md',
};
```

默认实现为：

```js
function isCategoryIndex({fileName, directories}) {
  const eligibleDocIndexNames = [
    'index',
    'readme',
    directories[0].toLowerCase(),
  ];
  return eligibleDocIndexNames.includes(fileName.toLowerCase());
}
```

</details>

## 自动生成的侧边栏元数据 {#autogenerated-sidebar-metadata}

对于手动编写的侧边栏定义，您可以通过 `sidebars.js` 提供元数据；而对于自动生成的，Docusaurus 会从每个项目的相应文件中读取元数据。此外，您可能希望调整每个项目的相对位置，因为默认情况下，侧边栏切片中的项目将按 **字母顺序** 生成（使用文件和文件夹名称）。

### 文档项目元数据 {#doc-item-metadata}

`label`、`className` 和 `customProps` 属性在前置文档中声明为 `sidebar_label`、`sidebar_class_name` 和 `sidebar_custom_props`，分别。位置可以通过 `sidebar_position` 前置文档以相同方式指定。

```md title="docs/tutorials/tutorial-easy.md"
---
# 高亮开始
sidebar_position: 2
sidebar_label: Easy
sidebar_class_name: green
# 高亮结束
---

# 简易教程

这是简易教程！
```

### 类别项目元数据 {#category-item-metadata}

在相应的文件夹中添加一个 `_category_.json` 或 `_category_.yml` 文件。您可以指定任何类别元数据以及 `position` 元数据。如果类别链接了文档，`label`、`className`、`position` 和 `customProps` 将默认取该文档的相应值。

<Tabs>
<TabItem value="JSON">

```json title="docs/tutorials/_category_.json"
{
  "position": 2.5,
  "label": "Tutorial",
  "collapsible": true,
  "collapsed": false,
  "className": "red",
  "link": {
    "type": "generated-index",
    "title": "Tutorial overview"
  },
  "customProps": {
    "description": "此描述可用于 swizzled DocCard"
  }
}
```

</TabItem>
<TabItem value="YAML">

```yml title="docs/tutorials/_category_.yml"
position: 2.5 # 支持浮动位置
label: 'Tutorial'
collapsible: true # 使类别可折叠
collapsed: false # 默认保持类别展开
className: red
link:
  type: generated-index
  title: Tutorial overview
customProps:
  description: 此描述可用于 swizzled DocCard
```

</TabItem>
</Tabs>

:::info

如果明确指定了 `link`，Docusaurus 将不应用任何 [默认约定](#category-index-convention)。

文档链接可以相对指定，例如，如果类别是从 `guides` 目录生成的，`"link": {"type": "doc", "id": "intro"}` 将解析为 ID `guides/intro`，只有在不存在具有前述 ID 的文档时才回退到 `intro`。

您还可以使用 `link: null` 来选择退出默认约定，不生成任何类别索引页面。

:::

:::info

位置元数据仅在 **侧边栏切片** 中使用：Docusaurus 不会重新排序您的侧边栏中的其他项目。

:::

## 使用数字前缀 {#using-number-prefixes}

一种简单的方式来排序自动生成的侧边栏是给文档和文件夹加上数字前缀，这样在按文件名排序时，它们在文件系统中也会以相同的顺序出现：

```bash
docs
├── 01-Intro.md
├── 02-Tutorial Easy
│   ├── 01-First Part.md
│   ├── 02-Second Part.md
│   └── 03-End.md
├── 03-Tutorial Advanced
│   ├── 01-First Part.md
│   ├── 02-Second Part.md
│   ├── 03-Third Part.md
│   └── 04-End.md
└── 04-End.md
```

为了 **更易于采用**，Docusaurus 支持 **多种数字前缀模式**。

默认情况下，Docusaurus 会 **从文档 ID、标题、标签和 URL 路径中移除数字前缀**。

:::warning

**建议使用 [附加元数据](#autogenerated-sidebar-metadata)**。

更新数字前缀可能会很麻烦，因为这可能需要 **更新多个现有的 Markdown 链接**：

```diff title="docs/02-Tutorial Easy/01-First Part.md"
- Check the [Tutorial End](../04-End.mdx);
+ Check the [Tutorial End](../05-End.mdx);
```

:::

## 自定义侧边栏项目生成器 {#customize-the-sidebar-items-generator}

您可以在文档插件（或预设）配置中提供自定义的 `sidebarItemsGenerator` 函数：

```js title="docusaurus.config.js"
export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        // 高亮开始
        async sidebarItemsGenerator({
          defaultSidebarItemsGenerator,
          numberPrefixParser,
          item,
          version,
          docs,
          categoriesMetadata,
          isCategoryIndex,
        }) {
          // 示例：返回一个硬编码的静态侧边栏项目列表
          return [
            {type: 'doc', id: 'doc1'},
            {type: 'doc', id: 'doc2'},
          ];
        },
        // 高亮结束
      },
    ],
  ],
};
```

:::tip

**重复使用并增强默认生成器**，而不是从头编写生成器：[我们提供的默认生成器](https://github.com/facebook/docusaurus/blob/main/packages/docusaurus-plugin-content-docs/src/sidebars/generator.ts) 约 250 行。

**根据您的用例添加、更新、过滤、重新排序** 侧边栏项目：

```js title="docusaurus.config.js"
// 高亮开始
// 反转侧边栏项目的排序（包括嵌套的类别项目）
function reverseSidebarItems(items) {
  // 反转类别中的项目
  const result = items.map((item) => {
    if (item.type === 'category') {
      return {...item, items: reverseSidebarItems(item.items)};
    }
    return item;
  });
  // 反转当前层级的项目
  result.reverse();
  return result;
}
// 高亮结束

export default {
  plugins: [
    [
      '@docusaurus/plugin-content-docs',
      {
        // 高亮开始
        async sidebarItemsGenerator({defaultSidebarItemsGenerator, ...args}) {
          const sidebarItems = await defaultSidebarItemsGenerator(args);
          return reverseSidebarItems(sidebarItems);
        },
        // 高亮结束
      },
    ],
  ],
};
``` 

:::